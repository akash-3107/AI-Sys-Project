# Repository for ws2324.1.3/team356
This is the repository for you solution. You can modify this README file any way you see fit.

**Topic:** WS2324 Assignment 1.3: Solve Nonograms

[Members: Akash Tambe, Prashansa Priyadarshini]

We implemented a solution to solve nonograms including implementation of various approaches to generate a Conjunctive Normal Form (CNF) encoding and compute a satisfiable solution using a SAT Solver.

File: 
1. main_nonogram.py
    - create_symbol_dictionary(max_value,helpVariable,multicolor_flag) : Create a symbol dictionary to maintain the corresponding cell values from the nonogram for encoding purpose
    - cnf_str_to_list(cnf_expr_clause_list, symbol_dictionary): Assign equivalent numbers according to encoding to generate input to the SAT solver
    - read_puzzle(path_to_file): Read the puzzle data from the nonogram problem file
    - generate_encoding_approach1_rect(rows,cols,clues,blocks): Generate DNF encoding using Approach 1 
    - approach1EncodingMultiColor(rows,cols,clues,blocks): This function is to generate encoding if two colours are present in the nonogram
    - truthtable(n,element): This function is for creating all possible combinations of the encoding
    - validateExpression_Multicolor(exp,Truthtable,cols,grid): Decide which encoding is acceptable according to the clue (For 2 colours)
    - validateExpression(exp,clues,Truthtable,cols,grid): Decide which encoding is acceptable according to the clue (For 1 colour)
    - generateDNF_multicolor(accepted,grid): Generate DNF for 2 colours
    - generateDNF(accepted,grid): Generate DNF for a single colour
    - validateAutomata(automata,TruthTable,cols,grid): To check whether the automata we create is valid or not
    - generate_encoding_approach4_rect(rows,cols,clues,blocks): Generate the encoding according to approach 4 
    - generateDNFString(ListDNF): Generate the DNF in a string format
    - generate_solution(sat_variable_list, rows, cols): Generate a final solution for the nonogram (For 1 colour)
    - generate_solution_color(sat_variable_list, rows, cols): Generate a final solution for the nonogram (For 2 colours)
    - create_solution_file(solution_array,file): Create the final solution file
    - AlredayCNF(clause): Check if any expression is already in the form of a CNF
    - create_cnf_and_implies(str, hVar): Intermediate function to convert implications to CNF form
    - create_cnf(clause,index): Generate CNF in a string format

2. Approach : 
    - We started with reading the puzzle attributes from the nonogram problem file
    - Post this, we generated an encoding from the clues mentioned in the problem file. Here we distinguish between the single coloured and multi-coloured nonograms.
    - While generating an encoding, we use two approaches mentioned in the assignment namely first and the fourth. 
    - In the fourth approach, we used automathon library to create the automata for each clue. We created an automata for each clue using automathon. We used itertools to generate all possible encoding combinations and selected the ones that was accepted by the automata to generate the DNF. We followed the similar process of converting the DNF to CNF and the solution towards the end as the 1st approach.
    - In first approach, we generate all possible combinations with the help of a library called Itertools. This library generates all possible combinations depending upon the number of colours in the clues file. 
    - We created a regex for each clue and passed the possible combinations generated by itertools through them and selected the satisfying(acceptable) ones.
    - from here we used those satisfying combinations to generate their corresponding DNF string using unique variable to identify each cell.
    -  Then we validate if the resulting string is already in CNF. If yes, we add it to a final CNF list. If not, we convert it to the CNF form using helper variables and add the generated string to the final CNF list.
    - To create an encoding in a specific format which is required by the SAT Solver, we maintained a symbol dictionary which assigned integer numbers to unique cell variables and helper variables.
    - Using this symbol dictionary, we converted the generated CNF String in the form of integer values (DIMACS Format from the assignment).
    - This list was then passed on to the SAT Solver which computed the satisfiability of every distinct variable.
    - After that, we created a solution array, be it a single colour nonogram problem or a multiple-coloured problem depending upon the satisfiability of the variables returned by the SAT Solver.
    - Once we had a final solution array, we created a solution file in an automated way
    
3. What worked well? What didn't?
    - Using itertools to generate all possible combinations worked fine for smaller nonograms but with larger ones(grid size : above 20 for single colour and above 10 for multi-colour) it used exponential search space which caused a bottleneck with respect to execution time and we couldn't completely use it. Even-though we were getting accurate solution using this approach. 
    - We previously started using SYMPY library to convert our DNF expressions to CNF which was causing issue as well since it was not able to convert it efficiently and correctly. So we decided to use helper variables instead and then it worked fine for us.
    - For multicolour clues, the visualization of the solution array was challenging for us as the identification of the actual colour from the model satisfiability was difficult. We also tried assigning ASCII values for differentiating between colours. But this created a huge model array from the SAT solver. 

With the above approach, we are able to create the solutions added to the folder 'clues_solutions'.


As an alternative to combat the bottleneck issue, we tried to implement the second approach. 

File :
1. Approach2.py
    - create_symbol_dictionary_2(max_value,clues,helpVarCount,multicolor_flag,list_symbol_dictionary): create dictionary containg numbers corresponsing to eachg variable.
    - cnf_str_to_list(cnf_expr_clause_list, symbol_dictionary): Convert the CNF string to CNF list splitting on AND and OR.
    - generateDNF_2(clue_dictionary,grid_layout): Create DNF for each clause depening on the clues sent.
    - generate_encoding_approach2_rect(row, col, clues): Generate encodings following 2nd approach
    - convert_implication_to_cnf(clause): Convert implies expression to CNF
    - convert_and_implication_cnf(clause,help_count): Convert AND and implies expression to CNF
    - convert_xor_1a(expr): Convert Xor expression for clues containing a single colored cells.
    - convert_xor_na_multiple(clause,helper_variable_count): Convert Xor expression for clues containing a multiple colored cells in accordance with another clues.
    - convert_xor_na(clause,helper_variable_count): Convert Xor expression for clues containing a multiple colored cells.
    - convert_xor_1a_multiple(expr): Convert Xor expression for clues containing a single colored cell which is in accordance with another clues
    
2. Approach :
    - We followed the initial part according to the approach mentioned above
    - In this approach, we just changed the code related to generation of the CNF encoding.
    - We initially assigned unique variables for each cell. Using those cells, we created 'XOR' expressions to showcase start of each block. 
    - After that, depending on the clues, we generated constraints on each cells depending upon the clues. We used the principle "if one block starts at a particular position, the next block
will not start too early"
    - Once we generated the above two things for all the clues, we converted them in form of a CNF using various intermediate functions listed above. 
    - The remaining part of generating the CNF list and computing the solution from a SAT Solver was followed similar to the approach mentioned before.
    - Post that, we visualized the actual solution and created the solution file

3. What worked well, what didn't?:
    - With additional contraints for each clues, the SAT solver was generating incorrect solutions for some of the multiple clues in single clause(eg: 2a 1a 2a). We created smaller nonograms for debugging purpose and they gave the correct solution. We modified our conversions of DNF to CNF as specified in the assignment for approach 2 variant 3. We then tried to remove some contraints and then it only worked till 4x4 grid(containing single clue in each clause). 
    - With this approach we saw that it was not using as much space as it did with the 1st one, even with larger nonograms. 
    - We created multiple smaller nonograms satisfying different situations like multiple colored(filename: test-1.clues, solution : test-1.solution) and having + in clue(filename:test-2.clues, solution : test-2.solution) and saw that the creation of solution was pretty quick and the solutions were also matching. We uploaded them to this repository as well for context.



Comparison of 2 approaches:
1. Comparing the Approach 1 and Approach 2 suggested in the assignment, we can surely state that as the grid size of the nonogram increases, Approach 2 scales better than approach 1 as the execution time for the generating the solution following second approach is lesser than generating it following the first one. 
2. This statement applies because, in the first approach, we consider all of the possible combinations of the encodings and then accept the satisfiable ones which significantly increases the execution time.
3. Whereas, in the second approach, we mention the constraints between the individual cells and let the SAT Solver compute the satisfiable solution of each cell variables.
4. So, as the number of combinations increase(i.e. the space complexity increases), we can say that the overall time complexity also increases.
5. For the first approach, time complexity is average, but the space complexity is worse. 
6. In case of the second approach, time and space complexity seems better.
